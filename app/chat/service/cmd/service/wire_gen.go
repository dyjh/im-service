// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"im-service/app/chat/service/cmd/service/handler"
	"im-service/app/chat/service/internal/biz"
	"im-service/app/chat/service/internal/conf"
	"im-service/app/chat/service/internal/data"
	"im-service/app/chat/service/internal/server"
	"im-service/app/chat/service/internal/service"
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"go.opentelemetry.io/otel/sdk/trace"
)

import (
	_ "go.uber.org/automaxprocs"
)

// Injectors from wire.go:

// wireApp init kratos application.
func wireApp(registry *conf.Registry, confBootstrup *conf.Bootstrap, logger log.Logger, logLevel string, tracerProvider *trace.TracerProvider) (*kratos.App, *handler.Handler, func(), error) {

	redis := data.NewRedisClient(confBootstrup.Data)
	mongo := data.NewMongo(confBootstrup.Data)
	mysql := data.NewMysql(confBootstrup.Data, logger)
	producer := data.NewMqProducer(confBootstrup.RocketMq, logLevel)
	clientManager := &handler.ClientManager{
		Clients:             make(map[string]*handler.Client), // 参与连接的用户，出于性能的考虑，需要设置最大连接数
		MapUserIdToClientId: make(map[uint]string),
		Register:            make(chan *handler.Client),
		Reply:               make(chan *handler.Client),
		Unregister:          make(chan *handler.Client),
		RedisClient:         redis,
		MongoDb: mongo,
		Mysql: mysql,
	}
	h := handler.NewHandler(producer, logger, clientManager)
	consumer, mqTag := data.NewMqConsumer(confBootstrup.RocketMq, logger, logLevel, h)
	dataData, cleanup, err := data.NewData(mongo, mysql, redis, producer, consumer, mqTag, logger, confBootstrup.Server, clientManager)
	if err != nil {
		return nil, nil, nil, err
	}
	wsRepo := data.NewWsRepo(dataData, logger)
	WsUseCase := biz.NewWsUseCase(wsRepo, logger)
	wsService := service.NewWsService(WsUseCase, logger)
	grpcServer := server.NewGRPCServer(confBootstrup.Server, wsService, tracerProvider, logger)
	httpServer := server.NewHTTPServer(confBootstrup.Server, tracerProvider, logger, h)
	registrar := server.NewRegistrar(registry)
	app := newApp(logger, grpcServer, httpServer, registrar)
	return app, h, func() {
		cleanup()
	}, nil
}

